
## ⚙️ **Workflow with Multiple Jobs in GitHub Actions**

---

### 🔹 **Why Use Multiple Jobs?**

* To run **independent tasks in parallel**, saving time.
* To **separate concerns** (e.g., build, test, deploy).
* To create **dependencies** where one job runs after another.

---

### 🔹 **Key Concepts**

* Each **job** runs on its own runner (VM).
* Jobs run **in parallel by default**.
* You can control execution order using `needs:` to create dependencies.

---

### 🔹 **Basic Syntax**

```yaml
jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      - run: echo "This is job 1"

  job2:
    runs-on: ubuntu-latest
    steps:
      - run: echo "This is job 2"
```

---

### 🔹 **Example: Build, Test, and Deploy Workflow**

```yaml
name: Build-Test-Deploy

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Build Application
        run: echo "Building app..."

  test:
    runs-on: ubuntu-latest
    needs: build           # Runs after 'build' job completes
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Run Tests
        run: echo "Running tests..."

  deploy:
    runs-on: ubuntu-latest
    needs: test           # Runs after 'test' job completes
    steps:
      - name: Deploy Application
        run: echo "Deploying app..."
```

---

### 🔹 **Explanation**

* **`build`** job runs first.
* When `build` completes successfully, **`test`** job starts.
* After successful `test`, **`deploy`** runs.
* If any job fails, the dependent jobs won’t run.

---

### 🔹 **Benefits**

* Parallel execution where possible.
* Clear separation of pipeline stages.
* Better control over workflow flow.

